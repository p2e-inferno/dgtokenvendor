{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/DGTokenVendor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IDGTokenVendor.sol\";\n\n// Custom errors\nerror AppChangeCooldownStillActive();\nerror CollectionAddressNotFound();\nerror CollectionAlreadyAdded();\nerror DailySellLimitExceeded();\nerror ExceedsMaxWhitelistedCollections();\nerror ETHTransferFailed();\nerror FeeCooldownActive();\nerror InsufficientPointsForUpgrade();\nerror InsufficientFuelForUpgrade();\nerror InvalidFeeBPS();\nerror InvalidDevAddress();\nerror InvalidExchangeRate();\nerror InsufficientBalance();\nerror InvalidFuelRate();\nerror InvalidPointsAwarded();\nerror InvalidDailyLimitMultiplier();\nerror InvalidBurnAmount();\nerror InvalidUpgradePointsThreshold();\nerror InvalidUpgradeFuelThreshold();\nerror InvalidQualifyingBuyThreshold();\nerror InvalidCooldown();\nerror MinimumAmountNotMet();\nerror MaxStageReached();\nerror NoValidKeyForUserFound();\nerror RateCooldownActive();\nerror StageSellLimitExceeded();\nerror StageCooldownActive();\nerror UnauthorizedCaller();\nerror WhitelistedCollectionsAlreadyInitialized();\n\ninterface IPublicLock {\n    function getHasValidKey(address _user) external view returns (bool);\n\n    function tokenOfOwnerByIndex(address _user, uint256 _index) external view returns (uint256);\n}\n\ncontract DGTokenVendor is Ownable, ReentrancyGuard, Pausable, IDGTokenVendor {\n    using SafeERC20 for IERC20;\n\n    // Core Constants\n    uint256 public constant MAX_WHITELISTED_COLLECTIONS = 10;\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant MAX_DAILY_MULTIPLIER = 100;\n    uint256 public constant MAX_FUEL_LIMIT = 100;\n    uint256 public constant MAX_FUEL_RATE = 5;\n    uint256 public constant MAX_POINTS_AWARDED = 5;\n    uint256 public constant MAX_SELL_BPS_LIMIT = 7000;\n    address public constant BURN_ADDRESS = 0x2Ef7DeC913e4127Fd0f94B32eeAd23ee63143598;\n\n    // State Variables\n    StageConstants stageConstants;\n    FeeConfig feeConfig;\n    TokenConfig tokenConfig;\n    SystemState systemState;\n    address[] private whitelistedCollections;\n\n    mapping(address => UserState) userStates;\n    mapping(UserStage => StageConfig) stageConfig;\n\n    modifier onlyNFTHolder() {\n        if (!hasValidKey(msg.sender)) revert NoValidKeyForUserFound();\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        if (!(msg.sender == owner() || msg.sender == systemState.devAddress)) revert UnauthorizedCaller();\n        _;\n    }\n\n    constructor(\n        address _baseToken,\n        address _swapToken,\n        uint256 _initialExchangeRate,\n        address _devAddress\n    ) Ownable(msg.sender) {\n        if (_initialExchangeRate == 0) revert InvalidExchangeRate();\n\n        // Initialize token config\n        tokenConfig = TokenConfig({\n            baseToken: IERC20(_baseToken),\n            swapToken: IERC20(_swapToken),\n            exchangeRate: _initialExchangeRate\n        });\n\n        // Initialize system state\n        systemState = SystemState({\n            baseTokenFees: 0,\n            swapTokenFees: 0,\n            lastRateChangeTimestamp: block.timestamp,\n            lastFeeChangeTimestamp: block.timestamp,\n            devAddress: _devAddress,\n            lastDevAddressChangeTimestamp: block.timestamp\n        });\n\n        // Initialize fee config\n        feeConfig = FeeConfig({\n            maxFeeBps: 1000,\n            buyFeeBps: 100,\n            sellFeeBps: 200,\n            rateChangeCooldown: 90 days,\n            appChangeCooldown: 90 days\n        });\n\n        // Initialize stage constants\n        stageConstants = StageConstants({\n            maxSellCooldown: 45 days,\n            dailyWindow: 24 hours,\n            minBuyAmount: 1000e18,\n            minSellAmount: 5000e18\n        }); \n\n        // Configure stages\n        stageConfig[UserStage.PLEB] = StageConfig({\n            burnAmount: 10e18,\n            upgradePointsThreshold: 0,\n            upgradeFuelThreshold: 5,\n            fuelRate: 1,\n            pointsAwarded: 1,\n            qualifyingBuyThreshold: 1000e18,\n            maxSellBps: 5000,\n            dailyLimitMultiplier: 100\n        });\n\n        stageConfig[UserStage.HUSTLER] = StageConfig({\n            burnAmount: 50e18,\n            upgradePointsThreshold: 100,\n            upgradeFuelThreshold: 15,\n            fuelRate: 2,\n            pointsAwarded: 2,\n            qualifyingBuyThreshold: 5000e18,\n            maxSellBps: 6000,\n            dailyLimitMultiplier: 100\n        });\n\n        stageConfig[UserStage.OG] = StageConfig({\n            burnAmount: 100e18,\n            upgradePointsThreshold: 500,\n            upgradeFuelThreshold: 30,\n            fuelRate: 3,\n            pointsAwarded: 3,\n            qualifyingBuyThreshold: 20000e18,\n            maxSellBps: 7000,\n            dailyLimitMultiplier: 100\n        });\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function buyTokens(uint256 amount) external nonReentrant onlyNFTHolder whenNotPaused {\n        if (amount < stageConstants.minBuyAmount) revert MinimumAmountNotMet();\n        if (tokenConfig.baseToken.balanceOf(msg.sender) < amount) revert InsufficientBalance();\n        uint256 fee = (amount * feeConfig.buyFeeBps) / BASIS_POINTS;\n        uint256 tokenToBuyAmount = (amount - fee) * tokenConfig.exchangeRate;\n\n        systemState.baseTokenFees += fee;\n        // Update user points\n        UserState storage user = userStates[msg.sender];\n        StageConfig memory config = stageConfig[user.stage];\n\n        // Award points if threshold met\n        if (amount >= config.qualifyingBuyThreshold) {\n            user.points += config.pointsAwarded;\n        }\n\n        tokenConfig.baseToken.safeTransferFrom(msg.sender, address(this), amount);\n        tokenConfig.swapToken.safeTransfer(msg.sender, tokenToBuyAmount);\n\n        emit TokensPurchased(msg.sender, amount, tokenToBuyAmount, fee);\n    }\n\n    function sellTokens(uint256 amount) external nonReentrant onlyNFTHolder whenNotPaused {\n        if (amount < stageConstants.minSellAmount) revert MinimumAmountNotMet();\n\n        // Calculate token conversion and fees\n        uint256 fee = (amount * feeConfig.sellFeeBps) / BASIS_POINTS;\n        uint256 tokensAmountAfterFee = amount - fee;\n        uint256 tokensToTransferAmount = tokensAmountAfterFee / tokenConfig.exchangeRate;\n        if (tokensToTransferAmount == 0) revert MinimumAmountNotMet();\n\n        UserState storage user = userStates[msg.sender];\n        StageConfig memory config = stageConfig[user.stage];\n\n        // Calculate maximum allowed transaction size\n        uint256 contractBalance = tokenConfig.baseToken.balanceOf(address(this));\n        uint256 maxTxSell = (contractBalance * config.maxSellBps) / BASIS_POINTS;\n\n        // Validate transaction limits\n        if (tokensToTransferAmount > maxTxSell) revert StageSellLimitExceeded();\n\n        // Handle OG stage cooldown for max-sized transactions\n        if (user.stage == UserStage.OG && tokensToTransferAmount == maxTxSell) {\n            if (block.timestamp <= user.lastStage3MaxSale + stageConstants.maxSellCooldown) {\n                revert StageCooldownActive();\n            }\n            user.lastStage3MaxSale = block.timestamp;\n        }\n\n        // Update daily tracking window\n        if (block.timestamp > user.dailyWindowStart + stageConstants.dailyWindow) {\n            user.dailySoldAmount = 0;\n            user.dailyWindowStart = block.timestamp;\n        }\n\n        // Calculate and validate daily limit\n        uint256 dailyLimit = config.qualifyingBuyThreshold * (config.dailyLimitMultiplier + user.fuel);\n        if (user.dailySoldAmount + tokensToTransferAmount > dailyLimit) {\n            revert DailySellLimitExceeded();\n        }\n\n        // Update state variables\n        user.dailySoldAmount += tokensToTransferAmount;\n        user.fuel = 0;\n        systemState.swapTokenFees += fee;\n\n        // Execute token transfers\n        tokenConfig.swapToken.safeTransferFrom(msg.sender, address(this), amount);\n        tokenConfig.baseToken.safeTransfer(msg.sender, tokensToTransferAmount);\n\n        emit TokensSold(msg.sender, amount, tokensToTransferAmount, fee);\n    }\n\n    function lightUp() external onlyNFTHolder whenNotPaused nonReentrant {\n        UserState storage user = userStates[msg.sender];\n        StageConfig memory config = stageConfig[UserStage(user.stage)];\n\n        tokenConfig.baseToken.safeTransferFrom(msg.sender, BURN_ADDRESS, config.burnAmount);\n\n        uint256 newFuel = Math.min(user.fuel + config.fuelRate, MAX_FUEL_LIMIT);\n\n        if (newFuel > user.fuel) user.fuel = newFuel;\n        emit Lit(msg.sender, config.burnAmount, newFuel);\n    }\n\n    function upgradeStage() external onlyNFTHolder whenNotPaused nonReentrant {\n        UserState storage user = userStates[msg.sender];\n\n        if (user.stage == UserStage.OG) revert MaxStageReached();\n        if (user.fuel < stageConfig[user.stage].upgradeFuelThreshold) revert InsufficientFuelForUpgrade();\n        if (user.points < stageConfig[user.stage].upgradePointsThreshold) revert InsufficientPointsForUpgrade();\n\n        if (user.stage == UserStage.PLEB) {\n            user.stage = UserStage.HUSTLER;\n        } else if (user.stage == UserStage.HUSTLER) {\n            user.stage = UserStage.OG;\n        }\n        user.points = 0;\n        user.fuel = 0;\n        emit StageUpgraded(msg.sender, user.stage);\n    }\n\n    function setExchangeRate(uint256 newRate) external onlyOwner {\n        if (block.timestamp < systemState.lastRateChangeTimestamp + feeConfig.rateChangeCooldown)\n            revert RateCooldownActive();\n        if (newRate == 0) revert InvalidExchangeRate();\n\n        tokenConfig.exchangeRate = newRate;\n        systemState.lastRateChangeTimestamp = block.timestamp;\n        emit ExchangeRateUpdated(newRate);\n    }\n\n    function setFeeRates(uint256 newBuyFeeBPS, uint256 newSellFeeBPS) external onlyOwner {\n        if (block.timestamp < systemState.lastFeeChangeTimestamp + feeConfig.appChangeCooldown)\n            revert FeeCooldownActive();\n        if (newBuyFeeBPS > feeConfig.maxFeeBps || newSellFeeBPS > feeConfig.maxFeeBps) revert InvalidFeeBPS();\n\n        feeConfig.buyFeeBps = newBuyFeeBPS;\n        feeConfig.sellFeeBps = newSellFeeBPS;\n        systemState.lastFeeChangeTimestamp = block.timestamp;\n        emit FeeRatesUpdated(newBuyFeeBPS, newSellFeeBPS);\n    }\n\n    function setDevAddress(address newDevAddress) external onlyOwner {\n        if (newDevAddress == address(0)) revert InvalidDevAddress();\n        if (block.timestamp < systemState.lastDevAddressChangeTimestamp + feeConfig.appChangeCooldown)\n            revert AppChangeCooldownStillActive();\n        systemState.devAddress = newDevAddress;\n        systemState.lastDevAddressChangeTimestamp = block.timestamp;\n        emit DevAddressUpdated(newDevAddress);\n    }\n\n    function withdrawFees() external nonReentrant onlyAuthorized whenNotPaused {\n        address to = systemState.devAddress;\n        uint256 baseTokenFeesToWithdraw = systemState.baseTokenFees;\n        uint256 swapTokenFeesToWithdraw = systemState.swapTokenFees;\n\n        systemState.baseTokenFees = 0;\n        systemState.swapTokenFees = 0;\n\n        if (baseTokenFeesToWithdraw > 0) {\n            tokenConfig.baseToken.safeTransfer(to, baseTokenFeesToWithdraw);\n        }\n\n        if (swapTokenFeesToWithdraw > 0) {\n            tokenConfig.swapToken.safeTransfer(to, swapTokenFeesToWithdraw);\n        }\n\n        emit FeesWithdrawn(to, baseTokenFeesToWithdraw, swapTokenFeesToWithdraw);\n    }\n\n    /**\n     * @dev Withdraw ETH from the contract (only admin)\n     */\n    function withdrawETH() external nonReentrant onlyAuthorized whenNotPaused {\n        address to = systemState.devAddress;\n        uint256 amount = address(this).balance;\n        (bool success, ) = to.call{ value: amount }(\"\");\n        if (!success) revert ETHTransferFailed();\n\n        emit ETHWithdrawn(to, amount);\n    }\n\n    function addWhitelistedCollection(address collectionAddress) external onlyOwner {\n        if (whitelistedCollections.length >= MAX_WHITELISTED_COLLECTIONS) revert ExceedsMaxWhitelistedCollections();\n        if (_isCollectionWhitelisted(collectionAddress)) revert CollectionAlreadyAdded();\n\n        whitelistedCollections.push(collectionAddress);\n        emit WhitelistedCollectionAdded(collectionAddress);\n    }\n\n    function batchAddWhitelistedCollections(address[] calldata collections) external onlyOwner {\n        if (whitelistedCollections.length + collections.length > MAX_WHITELISTED_COLLECTIONS)\n            revert ExceedsMaxWhitelistedCollections();\n\n        for (uint256 i = 0; i < collections.length; i++) {\n            if (!_isCollectionWhitelisted(collections[i])) {\n                whitelistedCollections.push(collections[i]);\n                emit WhitelistedCollectionAdded(collections[i]);\n            }\n        }\n    }\n\n    function removeWhitelistedCollection(address collectionAddress) external onlyOwner {\n        uint256 index = _findCollectionIndex(collectionAddress);\n        if (index >= whitelistedCollections.length) revert CollectionAddressNotFound();\n\n        whitelistedCollections[index] = whitelistedCollections[whitelistedCollections.length - 1];\n        whitelistedCollections.pop();\n        emit WhitelistedCollectionRemoved(collectionAddress);\n    }\n\n    function batchRemoveWhitelistedCollections(\n        address[] calldata collections\n    ) external onlyOwner {\n        uint256 length = collections.length;\n        for (uint256 i = length; i > 0; ) {\n            unchecked {\n                i--; \n            }\n            \n            address collection = collections[i];\n            uint256 index = _findCollectionIndex(collection);\n            if (index >= whitelistedCollections.length) {\n                revert CollectionAddressNotFound();\n            }\n\n            uint256 lastIndex = whitelistedCollections.length - 1;\n            if (index != lastIndex) {\n                whitelistedCollections[index] = whitelistedCollections[lastIndex];\n            }\n            whitelistedCollections.pop();\n\n            emit WhitelistedCollectionRemoved(collection);\n        }\n    }\n\n    function initializeWhitelistedCollections(address[] calldata collections) external onlyAuthorized {\n        if (whitelistedCollections.length + collections.length > MAX_WHITELISTED_COLLECTIONS)\n            revert ExceedsMaxWhitelistedCollections();\n        if (whitelistedCollections.length > 0) revert WhitelistedCollectionsAlreadyInitialized();\n\n        for (uint256 i = 0; i < collections.length; i++) {\n            if (!_isCollectionWhitelisted(collections[i])) {\n                whitelistedCollections.push(collections[i]);\n                emit WhitelistedCollectionAdded(collections[i]);\n            }\n        }\n    }\n\n    function canChangeFeeRates() external view returns (bool) {\n        return block.timestamp >= systemState.lastFeeChangeTimestamp + feeConfig.appChangeCooldown;\n    }\n\n    function canChangeExchangeRate() external view returns (bool) {\n        return block.timestamp >= systemState.lastRateChangeTimestamp + feeConfig.rateChangeCooldown;\n    }\n\n    function hasValidKey(address user) public view returns (bool) {\n        if (whitelistedCollections.length == 0) return false;\n\n        for (uint256 i = 0; i < whitelistedCollections.length; i++) {\n            if (IPublicLock(whitelistedCollections[i]).getHasValidKey(user)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getFirstValidCollection(address user) public view returns (address) {\n        for (uint256 i = 0; i < whitelistedCollections.length; i++) {\n            if (IPublicLock(whitelistedCollections[i]).getHasValidKey(user)) {\n                return whitelistedCollections[i];\n            }\n        }\n        return address(0);\n    }\n\n    function getStageConstants() public view returns (StageConstants memory _stageConstants) {\n        _stageConstants = stageConstants;\n    }\n\n    function getFeeConfig() public view returns (FeeConfig memory _feeConfig) {\n        _feeConfig = feeConfig;\n    }\n\n    function getTokenConfig() public view returns (TokenConfig memory _tokenConfig) {\n        _tokenConfig = tokenConfig;\n    }\n\n    function getSystemState() public view returns (SystemState memory _systemState) {\n        _systemState = systemState;\n    }\n\n    function getUserState(address user) public view returns (UserState memory _userState) {\n        _userState = userStates[user];\n    }\n\n    function getStageConfig(UserStage _stage) public view returns (StageConfig memory _stageConfig) {\n        _stageConfig = stageConfig[_stage];\n    }\n\n    function getExchangeRate() external view returns (uint256) {\n        return tokenConfig.exchangeRate;\n    }\n\n    function getWhitelistedCollections() external view returns (address[] memory) {\n        return whitelistedCollections;\n    }\n\n    function _isCollectionWhitelisted(address collectionAddress) internal view returns (bool) {\n        for (uint256 i = 0; i < whitelistedCollections.length; i++) {\n            if (whitelistedCollections[i] == collectionAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _findCollectionIndex(address collectionAddress) internal view returns (uint256) {\n        for (uint256 i = 0; i < whitelistedCollections.length; i++) {\n            if (whitelistedCollections[i] == collectionAddress) {\n                return i;\n            }\n        }\n        return whitelistedCollections.length;\n    }\n\n    function setStageConfig(UserStage _stage, StageConfig calldata _config) external onlyOwner {\n        uint256 minSellBps = 100;\n        uint256 invalidLowerBound = 0;\n        if (_config.maxSellBps < minSellBps || _config.maxSellBps > MAX_SELL_BPS_LIMIT) revert InvalidFeeBPS();\n        if (_config.fuelRate == invalidLowerBound || _config.fuelRate > MAX_FUEL_RATE) revert InvalidFuelRate();\n        if (_config.pointsAwarded == invalidLowerBound || _config.pointsAwarded > MAX_POINTS_AWARDED)\n            revert InvalidPointsAwarded();\n        if (_config.dailyLimitMultiplier == invalidLowerBound || _config.dailyLimitMultiplier > MAX_DAILY_MULTIPLIER)\n            revert InvalidDailyLimitMultiplier();\n        if (_config.burnAmount == invalidLowerBound) revert InvalidBurnAmount();\n        if (_config.upgradePointsThreshold == invalidLowerBound) revert InvalidUpgradePointsThreshold();\n        if (_config.upgradeFuelThreshold == invalidLowerBound) revert InvalidUpgradeFuelThreshold();\n        if (_config.qualifyingBuyThreshold == invalidLowerBound) revert InvalidQualifyingBuyThreshold();\n\n        StageConfig storage storedConfig = stageConfig[_stage];\n        StageConfig memory oldConfig = storedConfig;\n\n        storedConfig.burnAmount = _config.burnAmount;\n        storedConfig.upgradePointsThreshold = _config.upgradePointsThreshold;\n        storedConfig.upgradeFuelThreshold = _config.upgradeFuelThreshold;\n        storedConfig.fuelRate = _config.fuelRate;\n        storedConfig.pointsAwarded = _config.pointsAwarded;\n        storedConfig.qualifyingBuyThreshold = _config.qualifyingBuyThreshold;\n        storedConfig.maxSellBps = _config.maxSellBps;\n        storedConfig.dailyLimitMultiplier = _config.dailyLimitMultiplier;\n\n        emit StageConfigUpdated(_stage, oldConfig, storedConfig);\n    }\n\n    /**\n     * @notice Updates the fee configuration\n     * @param _rateChangeCooldown Cooldown for changing exchange rate\n     * @param _appChangeCooldown Cooldown for changing app settings\n     */\n    function setCooldownConfig(uint256 _rateChangeCooldown, uint256 _appChangeCooldown) external onlyOwner {\n        uint256 minCooldown = 14 days;\n        uint256 maxCooldown = 180 days;\n        if (_rateChangeCooldown < minCooldown || _rateChangeCooldown > maxCooldown) revert InvalidCooldown();\n        if (_appChangeCooldown < minCooldown || _appChangeCooldown > maxCooldown) revert InvalidCooldown();\n\n        feeConfig.rateChangeCooldown = _rateChangeCooldown;\n        feeConfig.appChangeCooldown = _appChangeCooldown;\n        emit FeeConfigUpdated(_rateChangeCooldown, _appChangeCooldown);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IDGTokenVendor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title IDGTokenVendor\r\n * @author Danny Thomx\r\n * @notice Interface for the DGTokenVendor contract\r\n * @dev Contains all external and public functions of the DGTokenVendor contract\r\n */\r\ninterface IDGTokenVendor {\r\n    /* ========== ENUMS & STRUCTS ========== */\r\n\r\n    /**\r\n     * @notice User progression stages\r\n     */\r\n    enum UserStage {\r\n        PLEB, // Entry level\r\n        HUSTLER, // Mid level\r\n        OG // Top level\r\n    }\r\n\r\n    /**\r\n     * @notice Configuration for each user stage\r\n     * @param burnAmount Amount of tokens burned for \"light up\" feature\r\n     * @param upgradePointsThreshold Points needed for upgrading to next stage\r\n     * @param upgradeFuelThreshold Fuel threshold for upgrade\r\n     * @param fuelRate Rate at which fuel increases\r\n     * @param pointsAwarded Points awarded for qualifying buy\r\n     * @param qualifyingBuyThreshold Minimum buy amount to earn points at this stage\r\n     * @param maxSellBps Maximum percentage of contract balance that can be sold in one tx\r\n     * @param dailyLimitMultiplier Multiplier for daily sell limit\r\n     */\r\n    struct StageConfig {\r\n        uint256 burnAmount;\r\n        uint256 upgradePointsThreshold;\r\n        uint256 upgradeFuelThreshold;\r\n        uint256 fuelRate;\r\n        uint256 pointsAwarded;\r\n        uint256 qualifyingBuyThreshold;\r\n        uint256 maxSellBps;\r\n        uint256 dailyLimitMultiplier;\r\n    }\r\n\r\n    /**\r\n     * @notice Constants for stage system timing and minimum amounts\r\n     * @param cooldown Cooldown period between stage operations\r\n     * @param dailyWindow Time window for daily limits\r\n     * @param minBuyAmount Minimum amount for buying tokens\r\n     * @param minSellAmount Minimum amount for selling tokens\r\n     */\r\n    struct StageConstants {\r\n        uint256 maxSellCooldown;\r\n        uint256 dailyWindow;\r\n        uint256 minBuyAmount;\r\n        uint256 minSellAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Individual user state\r\n     * @param stage Current user stage\r\n     * @param points Points earned toward next stage\r\n     * @param fuel Current fuel level\r\n     * @param lastStage3MaxSale Timestamp of last maximum stage 3 sale\r\n     * @param dailySoldAmount Amount sold in current daily window\r\n     * @param dailyWindowStart Start timestamp of current daily window\r\n     */\r\n    struct UserState {\r\n        UserStage stage;\r\n        uint256 points;\r\n        uint256 fuel;\r\n        uint256 lastStage3MaxSale;\r\n        uint256 dailySoldAmount;\r\n        uint256 dailyWindowStart;\r\n    }\r\n\r\n    /**\r\n     * @notice Fee configuration\r\n     * @param maxFeeBps Maximum fee in basis points\r\n     * @param buyFeeBps Fee for buying tokens in basis points\r\n     * @param sellFeeBps Fee for selling tokens in basis points\r\n     * @param rateChangeCooldown Cooldown for changing exchange rate\r\n     * @param appChangeCooldown Cooldown for changing app settings\r\n     */\r\n    struct FeeConfig {\r\n        uint256 maxFeeBps;\r\n        uint256 buyFeeBps;\r\n        uint256 sellFeeBps;\r\n        uint256 rateChangeCooldown;\r\n        uint256 appChangeCooldown;\r\n    }\r\n\r\n    /**\r\n     * @notice Token configuration\r\n     * @param baseToken The base token contract\r\n     * @param swapToken The swap token contract\r\n     * @param exchangeRate Exchange rate between tokens\r\n     */\r\n    struct TokenConfig {\r\n        IERC20 baseToken;\r\n        IERC20 swapToken;\r\n        uint256 exchangeRate;\r\n    }\r\n\r\n    /**\r\n     * @notice System state variables\r\n     * @param baseTokenFees Accumulated fees in base token\r\n     * @param swapTokenFees Accumulated fees in swap token\r\n     * @param lastRateChangeTimestamp Last time exchange rate was changed\r\n     * @param lastFeeChangeTimestamp Last time fees were changed\r\n     * @param devAddress Developer address for fee withdrawal\r\n     * @param lastDevAddressChangeTimestamp Last time dev address was changed\r\n     */\r\n    struct SystemState {\r\n        uint256 baseTokenFees;\r\n        uint256 swapTokenFees;\r\n        uint256 lastRateChangeTimestamp;\r\n        uint256 lastFeeChangeTimestamp;\r\n        address devAddress;\r\n        uint256 lastDevAddressChangeTimestamp;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @notice Emitted when tokens are purchased\r\n     * @param buyer Address of the buyer\r\n     * @param baseTokenAmount Amount of base tokens used\r\n     * @param swapTokenAmount Amount of swap tokens received\r\n     * @param fee Fee taken in base tokens\r\n     */\r\n    event TokensPurchased(address indexed buyer, uint256 baseTokenAmount, uint256 swapTokenAmount, uint256 fee);\r\n\r\n    /**\r\n     * @notice Emitted when tokens are sold\r\n     * @param seller Address of the seller\r\n     * @param swapTokenAmount Amount of swap tokens sold\r\n     * @param baseTokenAmount Amount of base tokens received\r\n     * @param fee Fee taken in swap tokens\r\n     */\r\n    event TokensSold(address indexed seller, uint256 swapTokenAmount, uint256 baseTokenAmount, uint256 fee);\r\n\r\n    /**\r\n     * @notice Emitted when a collection is added to whitelist\r\n     * @param collectionAddress Address of the added collection\r\n     */\r\n    event WhitelistedCollectionAdded(address indexed collectionAddress);\r\n\r\n    /**\r\n     * @notice Emitted when a collection is removed from whitelist\r\n     * @param collectionAddress Address of the removed collection\r\n     */\r\n    event WhitelistedCollectionRemoved(address indexed collectionAddress);\r\n\r\n    /**\r\n     * @notice Emitted when exchange rate is updated\r\n     * @param newRate New exchange rate\r\n     */\r\n    event ExchangeRateUpdated(uint256 newRate);\r\n\r\n    /**\r\n     * @notice Emitted when the developer address is updated\r\n     * @param newDevAddress The new developer address\r\n     */\r\n    event DevAddressUpdated(address indexed newDevAddress);\r\n\r\n    /**\r\n     * @notice Emitted when fees are withdrawn\r\n     * @param to Address receiving the fees\r\n     * @param baseTokenFees Amount of base token fees withdrawn\r\n     * @param swapTokenFees Amount of swap token fees withdrawn\r\n     */\r\n    event FeesWithdrawn(address indexed to, uint256 baseTokenFees, uint256 swapTokenFees);\r\n\r\n    /**\r\n     * @notice Emitted when ETH is withdrawn\r\n     * @param to Address receiving the ETH\r\n     * @param amount Amount of ETH withdrawn\r\n     */\r\n    event ETHWithdrawn(address indexed to, uint256 amount);\r\n\r\n    /**\r\n     * @notice Emitted when fee rates are updated\r\n     * @param newBuyFeeBPS New buy fee rate in basis points\r\n     * @param newSellFeeBPS New sell fee rate in basis points\r\n     */\r\n    event FeeRatesUpdated(uint256 newBuyFeeBPS, uint256 newSellFeeBPS);\r\n\r\n    /**\r\n     * @notice Emitted when a user upgrades to a new stage\r\n     * @param user User address\r\n     * @param newStage New stage of the user\r\n     */\r\n    event StageUpgraded(address indexed user, UserStage newStage);\r\n\r\n    /**\r\n     * @notice Emitted when a user uses the light up feature\r\n     * @param user User address\r\n     * @param burnAmount Amount of tokens burned\r\n     * @param newFuel New fuel level\r\n     */\r\n    event Lit(address indexed user, uint256 burnAmount, uint256 newFuel);\r\n\r\n    /**\r\n     * @notice Emitted when stage constants are updated\r\n     * @param parameter The name of the updated parameter\r\n     * @param value The new value\r\n     */\r\n    event StageConstantsUpdated(string parameter, uint256 value);\r\n\r\n    /**\r\n     * @notice Emitted when fee configuration cooldowns are updated\r\n     * @param rateChangeCooldown New rate change cooldown\r\n     * @param appChangeCooldown New app change cooldown\r\n     */\r\n    event FeeConfigUpdated(uint256 rateChangeCooldown, uint256 appChangeCooldown);\r\n\r\n    /**\r\n     * @notice Emitted when stage configuration is updated\r\n     * @param stage The stage being updated\r\n     * @param oldConfig Previous configuration\r\n     * @param newConfig New configuration\r\n     */\r\n    event StageConfigUpdated(UserStage indexed stage, StageConfig oldConfig, StageConfig newConfig);\r\n\r\n    /* ========== CORE CONSTANTS ========== */\r\n    function MAX_WHITELISTED_COLLECTIONS() external pure returns (uint256);\r\n\r\n    function BASIS_POINTS() external pure returns (uint256);\r\n\r\n    function MAX_DAILY_MULTIPLIER() external pure returns (uint256);\r\n\r\n    function MAX_FUEL_LIMIT() external pure returns (uint256);\r\n\r\n    function MAX_FUEL_RATE() external pure returns (uint256);\r\n\r\n    function MAX_POINTS_AWARDED() external pure returns (uint256);\r\n\r\n    function MAX_SELL_BPS_LIMIT() external pure returns (uint256);\r\n\r\n    function BURN_ADDRESS() external pure returns (address);\r\n\r\n    /* ========== USER FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Buy tokens using base token\r\n     * @param amount Amount of base token to use for purchase\r\n     */\r\n    function buyTokens(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Sell tokens to receive base token\r\n     * @param amount Amount of swap token to sell\r\n     */\r\n    function sellTokens(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Increase user's fuel by burning tokens\r\n     */\r\n    function lightUp() external;\r\n\r\n    /**\r\n     * @notice Upgrade user to next stage when requirements are met\r\n     */\r\n    function upgradeStage() external;\r\n\r\n    /* ========== ADMIN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Set new exchange rate\r\n     * @param newRate New exchange rate\r\n     */\r\n    function setExchangeRate(uint256 newRate) external;\r\n\r\n    /**\r\n     * @notice Set new fee rates\r\n     * @param newBuyFeeBPS New buy fee in basis points\r\n     * @param newSellFeeBPS New sell fee in basis points\r\n     */\r\n    function setFeeRates(uint256 newBuyFeeBPS, uint256 newSellFeeBPS) external;\r\n\r\n    /**\r\n     * @notice Set new developer address\r\n     * @param newDevAddress New developer address\r\n     */\r\n    function setDevAddress(address newDevAddress) external;\r\n\r\n    /**\r\n     * @notice Withdraw accumulated fees\r\n     */\r\n    function withdrawFees() external;\r\n\r\n    /**\r\n     * @notice Withdraw ETH from the contract\r\n     */\r\n    function withdrawETH() external;\r\n\r\n    /**\r\n     * @notice Add a new whitelisted collection\r\n     * @param collectionAddress Address of collection to whitelist\r\n     */\r\n    function addWhitelistedCollection(address collectionAddress) external;\r\n\r\n    /**\r\n     * @notice Remove a whitelisted collection\r\n     * @param collectionAddress Address of collection to remove\r\n     */\r\n    function removeWhitelistedCollection(address collectionAddress) external;\r\n\r\n    /**\r\n     * @notice Initialize the whitelisted collections \r\n     * @param collections Array of collection addresses to whitelist\r\n     */\r\n    function initializeWhitelistedCollections(address[] calldata collections) external;\r\n\r\n    /**\r\n     * @notice Batch add whitelisted collections\r\n     * @param _collectionAddresses Array of collection addresses to add\r\n     */\r\n    function batchAddWhitelistedCollections(address[] memory _collectionAddresses) external;\r\n\r\n    /**\r\n     * @notice Update stage configuration\r\n     * @param _stage The stage to update\r\n     * @param _config New configuration for the stage\r\n     */\r\n    function setStageConfig(UserStage _stage, StageConfig calldata _config) external;\r\n\r\n    /**\r\n     * @notice Update cooldown configuration\r\n     * @param _rateChangeCooldown New rate change cooldown\r\n     * @param _appChangeCooldown New app change cooldown\r\n     */\r\n    function setCooldownConfig(uint256 _rateChangeCooldown, uint256 _appChangeCooldown) external;\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Check if fee rates can be changed\r\n     * @return bool Whether fee rates can be changed\r\n     */\r\n    function canChangeFeeRates() external view returns (bool);\r\n\r\n    /**\r\n     * @notice Check if exchange rate can be changed\r\n     * @return bool Whether exchange rate can be changed\r\n     */\r\n    function canChangeExchangeRate() external view returns (bool);\r\n\r\n    /**\r\n     * @notice Check if user has a valid NFT key\r\n     * @param user Address to check\r\n     * @return bool Whether user has a valid key\r\n     */\r\n    function hasValidKey(address user) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Get the whitelisted collection for the first valid key a user has\r\n     * @param user Address to check\r\n     * @return address First valid collection address\r\n     */\r\n    function getFirstValidCollection(address user) external view returns (address);\r\n\r\n    /**\r\n     * @notice Get all whitelisted collections\r\n     * @return address[] Array of whitelisted collection addresses\r\n     */\r\n    function getWhitelistedCollections() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Get stage constants\r\n     * @return _stageConstants The stage constants\r\n     */\r\n    function getStageConstants() external view returns (StageConstants memory _stageConstants);\r\n\r\n    /**\r\n     * @notice Get fee configuration\r\n     * @return _feeConfig The fee configuration\r\n     */\r\n    function getFeeConfig() external view returns (FeeConfig memory _feeConfig);\r\n\r\n    /**\r\n     * @notice Get token configuration\r\n     * @return _tokenConfig The token configuration\r\n     */\r\n    function getTokenConfig() external view returns (TokenConfig memory _tokenConfig);\r\n\r\n    /**\r\n     * @notice Get system state\r\n     * @return _systemState The system state\r\n     */\r\n    function getSystemState() external view returns (SystemState memory _systemState);\r\n\r\n    /**\r\n     * @notice Get user state\r\n     * @param user The user address\r\n     * @return _userState The user state\r\n     */\r\n    function getUserState(address user) external view returns (UserState memory _userState);\r\n\r\n    /**\r\n     * @notice Get exchange rate\r\n     * @return _exchangeRate The exchange rate\r\n     */\r\n    function getExchangeRate() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get stage configuration\r\n     * @param _stage The stage to get configuration for\r\n     * @return _stageConfig The stage configuration\r\n     */\r\n    function getStageConfig(UserStage _stage) external view returns (StageConfig memory _stageConfig);\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}